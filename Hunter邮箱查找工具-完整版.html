<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hunter邮箱查找工具 - 完整版</title>
    
    <style>
        /* 全局样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* 头部样式 */
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        /* 卡片样式 */
        .card {
            background: white;
            border-radius: 8px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        /* 表单样式 */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .form-control {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea.form-control {
            resize: vertical;
            font-family: 'Courier New', monospace;
        }

        small {
            color: #666;
            font-size: 0.9em;
        }

        /* 按钮样式 */
        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            margin-right: 10px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #48bb78;
            color: white;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        /* API密钥卡片样式 */
        .api-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #667eea;
        }
        
        /* 展开/收起按钮样式 */
        .collapse-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: #667eea;
            font-weight: 600;
            margin-top: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.3s;
            user-select: none;
        }
        
        .collapse-toggle:hover {
            background-color: #f0f0f0;
        }
        
        .collapse-arrow {
            display: inline-block;
            transition: transform 0.3s;
            font-size: 0.8em;
        }
        
        .collapse-arrow.expanded {
            transform: rotate(90deg);
        }

        .api-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .api-input-group input {
            flex: 1;
        }

        .btn-icon {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.3s;
        }

        .btn-icon:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }

        .api-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .btn-small {
            padding: 8px 20px;
            font-size: 14px;
        }

        .btn-info {
            background: #3182ce;
            color: white;
        }

        .btn-info:hover {
            background: #2c5282;
        }

        .api-status {
            font-weight: 600;
            padding: 5px 10px;
            border-radius: 5px;
        }

        .api-status.success {
            color: #22543d;
            background: #c6f6d5;
        }

        .api-status.error {
            color: #742a2a;
            background: #fed7d7;
        }

        .api-status.testing {
            color: #92400e;
            background: #fef3c7;
        }

        .api-info {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        .api-info ul {
            margin: 10px 0 0 20px;
            line-height: 1.8;
        }

        /* 结果显示 */
        #results {
            margin-top: 30px;
        }

        .result-item {
            border-bottom: 1px solid #e0e0e0;
            padding: 20px 0;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .company-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .company-name {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
        }

        .domain {
            color: #667eea;
            font-family: 'Courier New', monospace;
        }

        .email-count {
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .email-list {
            margin-top: 15px;
        }

        .email-item {
            background: #f8f9fa;
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .email-address {
            font-family: 'Courier New', monospace;
            color: #2d3748;
            font-weight: 500;
        }

        .email-details {
            font-size: 0.9em;
            color: #666;
        }

        .confidence {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.85em;
            margin-left: 10px;
        }

        .confidence-high {
            background: #c6f6d5;
            color: #22543d;
        }

        .confidence-medium {
            background: #fef3c7;
            color: #92400e;
        }

        .confidence-low {
            background: #fed7d7;
            color: #742a2a;
        }

        /* 邮箱类型样式 */
        .email-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: 600;
            margin-right: 5px;
        }

        .type-personal {
            background: #e6f3ff;
            color: #0066cc;
        }

        .type-generic {
            background: #fff4e6;
            color: #cc6600;
        }

        .type-unknown {
            background: #f0f0f0;
            color: #666;
        }

        /* 加载动画 */
        .loading {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 错误消息 */
        .error {
            background: #fed7d7;
            color: #742a2a;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .success {
            background: #c6f6d5;
            color: #22543d;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        /* 操作按钮组 */
        .actions {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        /* 统计信息 */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        /* 格式信息 */
        .format-info {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            color: #666;
        }

        .format-info strong {
            color: #333;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            header h1 {
                font-size: 2em;
            }
            
            .card {
                padding: 20px;
            }
            
            .btn {
                display: block;
                width: 100%;
                margin-bottom: 10px;
            }
            
            .company-info {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .email-count {
                margin-top: 10px;
            }
        }

        /* 文件上传样式 */
        input[type="file"] {
            padding: 8px;
            background: #f8f9fa;
        }

        /* 分页控件样式 */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            gap: 10px;
        }

        .pagination button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }

        .pagination button:hover {
            background: #f5f5f5;
        }

        .pagination button:disabled {
            background: #f9f9f9;
            color: #ccc;
            cursor: not-allowed;
        }

        .pagination .current-page {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .pagination-info {
            margin: 0 15px;
            color: #666;
            font-size: 14px;
        }

        /* 页脚 */
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #666;
            font-size: 0.9em;
        }
        
        /* 滚动按钮 */
        .scroll-buttons {
            position: fixed;
            right: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }
        
        .scroll-btn {
            width: 45px;
            height: 45px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            opacity: 0.8;
        }
        
        .scroll-btn:hover {
            background: #5a67d8;
            transform: scale(1.1);
            opacity: 1;
        }
        
        .scroll-btn:active {
            transform: scale(0.95);
        }
        
        /* 隐藏/显示滚动按钮 */
        .scroll-buttons.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
    </style>
</head>
<body>
    <!-- 滚动按钮 -->
    <div class="scroll-buttons">
        <button class="scroll-btn" onclick="scrollToTop()" title="回到顶部">↑</button>
        <button class="scroll-btn" onclick="scrollToBottom()" title="去到底部">↓</button>
    </div>
    
    <div class="container">
        <header>
            <h1>🔍 Hunter邮箱查找工具</h1>
            <p>使用 Hunter.io API 查找公司域名的邮箱地址 - 完整独立版</p>
        </header>

        <div class="main-content">
            <!-- API密钥设置 -->
            <div class="card api-card">
                <h2>🔑 API 密钥设置</h2>
                <div class="form-group">
                    <label for="apiKey">Hunter.io API 密钥:</label>
                    <div class="api-input-group">
                        <input type="password" id="apiKey" placeholder="输入你的 Hunter.io API 密钥" class="form-control">
                        <button onclick="toggleApiKeyVisibility()" class="btn-icon" title="显示/隐藏密钥">
                            <span id="toggleIcon">👁️</span>
                        </button>
                    </div>
                    <div class="api-actions">
                        <button onclick="saveApiKey()" class="btn btn-small btn-primary">保存密钥</button>
                        <button onclick="clearApiKey()" class="btn btn-small btn-secondary">清除密钥</button>
                        <button onclick="testApiKey()" class="btn btn-small btn-info">测试连接</button>
                    </div>
                    <small>
                        <span id="apiStatus" class="api-status"></span>
                        <br>
                        获取密钥: <a href="https://hunter.io/api" target="_blank">https://hunter.io/api</a> | 
                        <a href="https://hunter.io/api-keys" target="_blank">管理密钥</a>
                    </small>
                </div>
                <div class="collapse-toggle" onclick="toggleApiInfo('hunter')">
                    <span class="collapse-arrow" id="hunterArrow">▶</span>
                    <span>说明</span>
                </div>
                <div class="api-info" id="hunterApiInfo" style="display: none;">
                    <ul>
                        <li>密钥将安全保存在浏览器本地存储中</li>
                        <li>关闭浏览器后密钥仍会保留</li>
                        <li>密钥不会上传到服务器或保存在文件中</li>
                        <li>如需更换密钥，点击"清除密钥"后重新输入</li>
                    </ul>
                </div>
            </div>

            <!-- ChatGPT API设置 -->
            <div class="card api-card">
                <h2>🤖 ChatGPT API 设置（可选）</h2>
                <div class="collapse-toggle" onclick="toggleApiInfo('openai')" style="margin-bottom: 15px;">
                    <span class="collapse-arrow" id="openaiArrow">▶</span>
                    <span>展开设置</span>
                </div>
                <div id="openaiApiInfo" style="display: none;">
                <div class="form-group">
                    <label for="openaiKey">OpenAI API 密钥:</label>
                    <div class="api-input-group">
                        <input type="password" id="openaiKey" placeholder="输入你的 OpenAI API 密钥（sk-...）" class="form-control">
                        <button onclick="toggleOpenAIKeyVisibility()" class="btn-icon" title="显示/隐藏密钥">
                            <span id="toggleOpenAIIcon">👁️</span>
                        </button>
                    </div>
                    <div class="api-actions">
                        <button onclick="saveOpenAIKey()" class="btn btn-small btn-primary">保存密钥</button>
                        <button onclick="clearOpenAIKey()" class="btn btn-small btn-secondary">清除密钥</button>
                        <button onclick="testOpenAIKey()" class="btn btn-small btn-info">测试连接</button>
                    </div>
                    <small>
                        <span id="openaiStatus" class="api-status"></span>
                        <br>
                        获取密钥: <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI API Keys</a>
                    </small>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="enableNameGuessing" checked style="margin-right: 8px;">
                        启用智能名字猜测功能
                    </label>
                    <small style="display: block; margin-top: 5px;">
                        启用后，AI会智能分析邮箱地址，提取或猜测合理的名字和姓氏
                    </small>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="overrideExistingNames" style="margin-right: 8px;">
                        覆盖Hunter提供的名字（使用AI重新分析所有邮箱）
                    </label>
                    <small style="display: block; margin-top: 5px;">
                        勾选后，即使Hunter已提供名字，AI也会重新分析
                    </small>
                </div>
                <div class="api-info" style="margin-top: 15px;">
                    <ul>
                        <li>AI会智能分析邮箱地址，提取或猜测合理的名字</li>
                        <li>对于明确的名字（如john.smith@），AI会提取完整名字</li>
                        <li>对于单个首字母+姓氏模式（如acarnes@），AI会保守处理，保留首字母（如A. Carnes）</li>
                        <li>对于不清晰的模式（如rgmora@），AI会提取可识别部分（如RG Mora）</li>
                        <li>AI会标记哪些是猜测的名字，哪些是提取的名字</li>
                        <li>此功能需要消耗OpenAI API积分，请合理使用</li>
                    </ul>
                </div>
                </div>
            </div>

            <!-- Claude API设置 -->
            <div class="card api-card">
                <h2>🤖 Claude API 设置（可选）</h2>
                <div class="collapse-toggle" onclick="toggleApiInfo('claude')" style="margin-bottom: 15px;">
                    <span class="collapse-arrow" id="claudeArrow">▶</span>
                    <span>展开设置</span>
                </div>
                <div id="claudeApiInfo" style="display: none;">
                <div class="form-group">
                    <label for="proxyUrl">代理服务器地址:</label>
                    <input type="text" id="proxyUrl" placeholder="http://localhost:3001" value="http://localhost:3001" class="form-control">
                    <small>Claude API需要通过代理服务器访问。<a href="#" onclick="showProxySetup(); return false;">查看设置说明</a></small>
                </div>
                <div class="form-group">
                    <label for="claudeKey">Claude API 密钥:</label>
                    <div class="api-input-group">
                        <input type="password" id="claudeKey" placeholder="输入你的 Claude API 密钥" class="form-control">
                        <button onclick="toggleClaudeKeyVisibility()" class="btn-icon" title="显示/隐藏密钥">
                            <span id="toggleClaudeIcon">👁️</span>
                        </button>
                    </div>
                    <div class="api-actions">
                        <button onclick="saveClaudeKey()" class="btn btn-small btn-primary">保存密钥</button>
                        <button onclick="clearClaudeKey()" class="btn btn-small btn-secondary">清除密钥</button>
                        <button onclick="testClaudeKey()" class="btn btn-small btn-info">测试连接</button>
                    </div>
                    <small>
                        <span id="claudeStatus" class="api-status"></span>
                        <br>
                        获取密钥: <a href="https://console.anthropic.com/api" target="_blank">Anthropic Console</a>
                    </small>
                </div>
                <div class="form-group">
                    <label>选择AI提供商:</label>
                    <div style="margin-top: 10px;">
                        <label style="margin-right: 20px;">
                            <input type="radio" name="aiProvider" value="openai" id="useOpenAI" checked style="margin-right: 5px;">
                            使用 OpenAI (GPT-4)
                        </label>
                        <label>
                            <input type="radio" name="aiProvider" value="claude" id="useClaude" style="margin-right: 5px;">
                            使用 Claude (Haiku 3.5)
                        </label>
                    </div>
                    <small style="display: block; margin-top: 10px;">
                        选择用于智能名字猜测的AI服务。两者效果相似，可根据您的密钥情况选择。
                    </small>
                </div>
                <div class="api-info" style="margin-top: 15px;">
                    <ul>
                        <li>Claude AI 提供与 OpenAI 相似的智能分析功能</li>
                        <li>使用 Claude 3.5 Haiku 模型，速度快、成本极低</li>
                        <li>对于邮箱地址的名字提取和分析效果良好</li>
                        <li>API 调用费用比 GPT-4 和 Sonnet 都要低很多</li>
                        <li>支持批量处理，提高效率</li>
                    </ul>
                </div>
                </div>
            </div>

            <!-- 单个域名查找 -->
            <div class="card">
                <h2>单个域名查找</h2>
                <div class="collapse-toggle" onclick="toggleSection('singleSearch')" style="margin-bottom: 15px;">
                    <span class="collapse-arrow" id="singleSearchArrow">▶</span>
                    <span>展开查找界面</span>
                </div>
                <div id="singleSearchSection" style="display: none;">
                <div class="form-group">
                    <label for="singleDomain">域名或网址:</label>
                    <input type="text" id="singleDomain" placeholder="例如: example.com 或 https://www.example.com" class="form-control">
                </div>
                <div class="form-group">
                    <label for="companyName">公司名称 (可选):</label>
                    <input type="text" id="companyName" placeholder="例如: Example Inc." class="form-control">
                </div>
                <div class="form-group">
                    <label for="emailLimit">邮箱数量限制:</label>
                    <input type="number" id="emailLimit" value="10" min="1" max="100" class="form-control">
                </div>
                <button onclick="searchSingle()" class="btn btn-primary">查找邮箱</button>
                </div>
            </div>

            <!-- 批量查找 -->
            <div class="card">
                <h2>批量域名查找</h2>
                <div class="form-group">
                    <label for="batchInput">域名列表 (每行一个):</label>
                    <textarea id="batchInput" rows="5" placeholder="example1.com
example2.com
https://example3.com" class="form-control"></textarea>
                </div>
                <div class="form-group">
                    <label>或上传文件 (CSV/TXT):</label>
                    <input type="file" id="csvFile" accept=".csv,.txt" class="form-control">
                    <small>
                        支持格式：<br>
                        • CSV: company_name, domain/website<br>
                        • TXT: JSON格式 [{"company_name": "公司名", "website": "网址"}]
                    </small>
                </div>
                <button onclick="searchBatch()" class="btn btn-primary">批量查找</button>
            </div>

            <!-- JSON文件处理 -->
            <div class="card">
                <h2>🔧 JSON文件处理工具</h2>
                <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                    上传包含公司信息的TXT/JSON文件，自动去重、修复格式错误并标准化数据
                </p>
                <div class="collapse-toggle" onclick="toggleSection('jsonProcessor')" style="margin-bottom: 15px;">
                    <span class="collapse-arrow" id="jsonProcessorArrow">▶</span>
                    <span>展开处理界面</span>
                </div>
                <div id="jsonProcessorSection" style="display: none;">
                    <div class="form-group">
                        <label for="jsonFile">选择JSON/TXT文件:</label>
                        <input type="file" id="jsonFile" accept=".txt,.json" onchange="previewJsonFile()">
                        <small>
                            支持格式：<br>
                            • 单个数组：[{"company_name": "公司名", "website": "网址"}]<br>
                            • 多个数组：[{...}][{...}]...<br>
                            • 自动修复常见JSON错误（尾随逗号等）
                        </small>
                    </div>
                    <div id="jsonPreview" style="display: none; margin-top: 15px;">
                        <h3 style="font-size: 16px; margin-bottom: 10px;">文件预览</h3>
                        <div id="jsonPreviewContent" style="background: #f5f5f5; padding: 10px; border-radius: 5px; font-size: 12px; max-height: 200px; overflow-y: auto; white-space: pre-wrap; font-family: monospace;"></div>
                        <div style="margin-top: 10px;">
                            <small>原始数据统计：<span id="jsonStats" style="font-weight: bold;"></span></small>
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 15px;">
                        <label>
                            <input type="checkbox" id="removeDuplicates" checked>
                            去除重复数据（基于域名）
                        </label>
                    </div>
                    <button onclick="processJsonFile()" class="btn btn-primary">处理文件</button>
                    
                    <!-- 处理结果显示 -->
                    <div id="jsonResults" style="display: none; margin-top: 20px; padding: 15px; background: #f0f9ff; border-radius: 5px;">
                        <h3 style="font-size: 16px; margin-bottom: 10px; color: #22543d;">✅ 处理完成</h3>
                        <p id="jsonResultText" style="margin-bottom: 15px;"></p>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button onclick="downloadProcessedJson()" class="btn btn-primary">下载JSON格式</button>
                            <button onclick="downloadProcessedCsv()" class="btn btn-primary">下载CSV格式</button>
                            <button onclick="copyToClipboard()" class="btn btn-secondary">复制到剪贴板</button>
                            <button onclick="clearJsonResults()" class="btn btn-secondary">清除结果</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CSV文件称呼生成 -->
            <div class="card">
                <h2>📝 CSV文件称呼生成</h2>
                <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                    上传已有的CSV文件（如从Instantly导出的），仅使用AI生成称呼，无需调用Hunter API
                </p>
                <div class="collapse-toggle" onclick="toggleSection('csvGreeting')" style="margin-bottom: 15px;">
                    <span class="collapse-arrow" id="csvGreetingArrow">▶</span>
                    <span>展开生成界面</span>
                </div>
                <div id="csvGreetingSection" style="display: none;">
                <div class="form-group">
                    <label for="greetingCsvFile">选择CSV文件:</label>
                    <input type="file" id="greetingCsvFile" accept=".csv" onchange="previewCsvFile()">
                    <small>支持格式：CSV文件，包含email列</small>
                </div>
                <div id="csvPreview" style="display: none; margin-top: 15px;">
                    <h3 style="font-size: 16px; margin-bottom: 10px;">文件预览</h3>
                    <div id="csvPreviewContent" style="background: #f5f5f5; padding: 10px; border-radius: 5px; font-size: 12px; max-height: 200px; overflow-y: auto;"></div>
                    <div style="margin-top: 10px;">
                        <small>检测到的列：<span id="detectedColumns" style="font-weight: bold;"></span></small>
                    </div>
                </div>
                <div class="form-group" style="margin-top: 15px;">
                    <label>
                        <input type="checkbox" id="overrideGreetings">
                        覆盖已有的名字（默认仅处理空白名字）
                    </label>
                </div>
                <button onclick="generateGreetingsOnly()" class="btn btn-primary">生成称呼</button>
                
                <!-- 生成结果显示 -->
                <div id="greetingResults" style="display: none; margin-top: 20px; padding: 15px; background: #f0f9ff; border-radius: 5px;">
                    <h3 style="font-size: 16px; margin-bottom: 10px; color: #22543d;">✅ 称呼生成完成</h3>
                    <p id="greetingResultText" style="margin-bottom: 15px;"></p>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="downloadGeneratedGreetings()" class="btn btn-primary">下载生成的文件</button>
                        <button onclick="clearGreetingResults()" class="btn btn-secondary">清除结果</button>
                    </div>
                </div>
                </div>
            </div>

            <!-- 结果显示区域 -->
            <div id="results" class="card" style="display: none;">
                <h2>查找结果</h2>
                <div id="resultContent"></div>
                <div class="actions">
                    <button onclick="downloadInstantlyCSV()" class="btn btn-primary">下载 Instantly 格式</button>
                    <button onclick="downloadFailedCompaniesCSV()" class="btn btn-secondary">下载未找到邮箱的公司</button>
                    <button onclick="clearResults()" class="btn btn-secondary">清除结果</button>
                </div>
                <div class="format-info">
                    <small>
                        <strong>Instantly格式</strong>：Email, First Name, Last Name, Company Name, Phone, Job Title, Country<br>
                        <strong>未找到邮箱的公司</strong>：包含查找失败或没有找到邮箱的公司列表
                    </small>
                </div>
            </div>

            <!-- 加载提示 -->
            <div id="loading" class="loading" style="display: none;">
                <div class="spinner"></div>
                <p>正在查找邮箱...</p>
            </div>
        </div>

        <!-- 系统日志 -->
        <div class="card" style="margin-top: 20px;">
            <h2>🔧 系统日志</h2>
            <div style="margin-bottom: 15px;">
                <button onclick="AppLogger.exportLogs()" class="btn btn-small btn-secondary">导出日志</button>
                <button onclick="refreshLogDisplay()" class="btn btn-small btn-primary">刷新</button>
                <button onclick="AppLogger.clearLogs(); refreshLogDisplay();" class="btn btn-small btn-secondary">清除日志</button>
                <button onclick="toggleLogPanel()" class="btn btn-small btn-info">显示/隐藏</button>
            </div>
            <div id="logPanel" style="display: none;">
                <div style="max-height: 300px; overflow-y: auto; background: #f5f5f5; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px;">
                    <div id="logContent"></div>
                </div>
            </div>
        </div>

        <footer>
            <p>© 2025 Hunter邮箱查找工具 - 完整独立版 | 基于 Hunter.io API</p>
        </footer>
    </div>

    <script>
        // 全局变量存储结果
        let currentResults = [];
        
        // 分页相关变量
        let currentPage = 1;
        const resultsPerPage = 50;
        
        // 缓存猜测的名字，避免重复调用API
        const nameGuessCache = new Map();
        
        // Claude代理服务器URL（本地开发时使用localhost:3001）
        let CLAUDE_PROXY_URL = localStorage.getItem('claudeProxyUrl') || 'http://localhost:3001';
        
        // 日志系统
        const AppLogger = {
            logs: [],
            maxLogs: 1000,
            
            log: function(level, message, data = {}) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    level: level,
                    message: message,
                    data: data,
                    userAgent: navigator.userAgent
                };
                
                this.logs.push(logEntry);
                
                // 保持日志数量在限制内
                if (this.logs.length > this.maxLogs) {
                    this.logs.shift();
                }
                
                // 同时输出到控制台
                console.log(`[${level}] ${message}`, data);
                
                // 保存到本地存储
                this.saveLogs();
            },
            
            info: function(message, data) {
                this.log('INFO', message, data);
            },
            
            error: function(message, data) {
                this.log('ERROR', message, data);
            },
            
            warn: function(message, data) {
                this.log('WARN', message, data);
            },
            
            debug: function(message, data) {
                this.log('DEBUG', message, data);
            },
            
            saveLogs: function() {
                try {
                    localStorage.setItem('hunterAppLogs', JSON.stringify(this.logs));
                } catch (e) {
                    console.error('Failed to save logs:', e);
                }
            },
            
            loadLogs: function() {
                try {
                    const saved = localStorage.getItem('hunterAppLogs');
                    if (saved) {
                        this.logs = JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Failed to load logs:', e);
                }
            },
            
            getLogs: function(level = null) {
                if (level) {
                    return this.logs.filter(log => log.level === level);
                }
                return this.logs;
            },
            
            exportLogs: function() {
                const logText = this.logs.map(log => 
                    `[${log.timestamp}] [${log.level}] ${log.message} ${JSON.stringify(log.data)}`
                ).join('\n');
                
                const blob = new Blob([logText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hunter-logs-${new Date().toISOString().split('T')[0]}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },
            
            clearLogs: function() {
                this.logs = [];
                this.saveLogs();
            }
        };

        // 获取API密钥
        function getApiKey() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                alert('请输入 Hunter.io API 密钥');
                return null;
            }
            return apiKey;
        }

        // 单个域名查找
        async function searchSingle() {
            const apiKey = getApiKey();
            if (!apiKey) return;

            const domain = document.getElementById('singleDomain').value.trim();
            const companyName = document.getElementById('companyName').value.trim();
            const limit = document.getElementById('emailLimit').value;

            if (!domain) {
                alert('请输入域名或网址');
                return;
            }
            
            AppLogger.info('开始单个域名查找', { domain, companyName, limit });
            showLoading(true);
            
            try {
                const result = await searchDomain(apiKey, domain, companyName, limit);
                currentResults = [result];
                
                // 如果启用了AI功能，批量处理邮箱
                const enableGuessing = document.getElementById('enableNameGuessing').checked;
                const useOpenAI = document.getElementById('useOpenAI').checked;
                const openaiKey = localStorage.getItem('openaiApiKey');
                const claudeKey = localStorage.getItem('claudeApiKey');
                const hasValidKey = useOpenAI ? openaiKey : claudeKey;
                
                if (enableGuessing && hasValidKey && result.success && result.emails) {
                    updateLoadingText('正在使用AI智能生成称呼...');
                    
                    // 收集需要处理的邮箱
                    const overrideExisting = document.getElementById('overrideExistingNames').checked;
                    const emailsToProcess = [];
                    result.emails.forEach((email, index) => {
                        const shouldProcess = (email.type === 'personal' || email.type === 'generic') && 
                                            (overrideExisting || !email.first_name);
                        if (shouldProcess) {
                            emailsToProcess.push({
                                email: email.email,
                                companyName: result.company_name,
                                index: index
                            });
                        }
                    });
                    
                    AppLogger.info('AI处理邮箱', { 
                        totalEmails: result.emails.length,
                        toProcess: emailsToProcess.length,
                        overrideExisting 
                    });
                    
                    if (emailsToProcess.length > 0) {
                        // 批量处理
                        const batch = emailsToProcess.map(item => ({
                            email: item.email,
                            companyName: item.companyName
                        }));
                        
                        const aiResults = await batchProcessEmailsWithAI(batch);
                        
                        // 应用AI结果
                        emailsToProcess.forEach(item => {
                            const aiResult = aiResults.get(item.email);
                            if (aiResult) {
                                const email = result.emails[item.index];
                                if (aiResult.first_name) {
                                    email.first_name = aiResult.first_name;
                                }
                                if (aiResult.last_name && !email.last_name) {
                                    email.last_name = aiResult.last_name;
                                }
                                email.ai_generated = true;
                                email.is_guess = aiResult.is_guess;
                            }
                        });
                    }
                }
                
                displayResults(currentResults);
                AppLogger.info('单个域名查找成功', { 
                    domain, 
                    emailsFound: result.emails_found || 0,
                    success: result.success 
                });
            } catch (error) {
                AppLogger.error('单个域名查找失败', { domain, error: error.message });
                alert('查找失败: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // 批量查找
        async function searchBatch() {
            const apiKey = getApiKey();
            if (!apiKey) return;

            let domains = [];
            
            // 从文本框获取
            const batchText = document.getElementById('batchInput').value.trim();
            if (batchText) {
                domains = batchText.split('\n').map(line => ({
                    domain: line.trim(),
                    company_name: ''
                })).filter(item => item.domain);
            }
            
            // 从文件获取（CSV或TXT）
            const fileInput = document.getElementById('csvFile');
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const fileData = await readUploadedFile(file);
                domains = domains.concat(fileData);
            }
            
            if (domains.length === 0) {
                alert('请输入域名或上传文件（支持CSV/TXT格式）');
                return;
            }
            
            // 添加批量处理数量限制
            const maxBatchSize = 250;
            if (domains.length > maxBatchSize) {
                if (!confirm(`检测到 ${domains.length} 个公司，超过建议的 ${maxBatchSize} 个限制。\n\n处理大量数据可能会：\n• 消耗较多API配额\n• 影响页面性能\n• 可能导致部分数据丢失\n\n建议分批处理。是否继续处理前 ${maxBatchSize} 个公司？`)) {
                    return;
                }
                domains = domains.slice(0, maxBatchSize);
                alert(`已限制为前 ${maxBatchSize} 个公司进行处理`);
            }
            
            showLoading(true);
            currentResults = [];
            
            try {
                // 第一阶段：批量查找所有域名
                for (let i = 0; i < domains.length; i++) {
                    const item = domains[i];
                    updateLoadingText(`正在查找 ${i + 1}/${domains.length}: ${item.domain}`);
                    
                    try {
                        const result = await searchDomain(apiKey, item.domain, item.company_name);
                        currentResults.push(result);
                        displayResults(currentResults);
                    } catch (error) {
                        console.error(`Error for ${item.domain}:`, error);
                        currentResults.push({
                            company_name: item.company_name || item.domain,
                            domain: item.domain,
                            success: false,
                            error: error.message,
                            emails: []
                        });
                    }
                    
                    // 延迟以避免速率限制
                    if (i < domains.length - 1) {
                        await delay(1000);
                    }
                }
                
                // 第二阶段：批量处理AI名字猜测（如果启用）
                const enableGuessing = document.getElementById('enableNameGuessing').checked;
                const useOpenAI = document.getElementById('useOpenAI').checked;
                const openaiKey = localStorage.getItem('openaiApiKey');
                const claudeKey = localStorage.getItem('claudeApiKey');
                const hasValidKey = useOpenAI ? openaiKey : claudeKey;
                
                if (enableGuessing && hasValidKey) {
                    updateLoadingText('正在使用AI智能生成称呼...');
                    
                    // 收集所有需要处理的邮箱，同时去重
                    const overrideExisting = document.getElementById('overrideExistingNames').checked;
                    const emailsToProcess = new Map();
                    const emailToResults = new Map(); // 记录邮箱对应的结果索引
                    
                    currentResults.forEach((result, resultIndex) => {
                        if (result.success && result.emails) {
                            result.emails.forEach((email, emailIndex) => {
                                const shouldProcess = (email.type === 'personal' || email.type === 'generic') && 
                                                    (overrideExisting || !email.first_name);
                                if (shouldProcess) {
                                    const key = email.email;
                                    if (!emailsToProcess.has(key)) {
                                        emailsToProcess.set(key, {
                                            email: email.email,
                                            companyName: result.company_name
                                        });
                                        emailToResults.set(key, []);
                                    }
                                    // 记录这个邮箱在哪些结果中出现
                                    emailToResults.get(key).push({ resultIndex, emailIndex });
                                }
                            });
                        }
                    });
                    
                    // 智能计算批次策略
                    const emailArray = Array.from(emailsToProcess.values());
                    const totalEmails = emailArray.length;
                    let batchStrategy = [];
                    
                    if (totalEmails <= 30) {
                        batchStrategy = [totalEmails];
                    } else if (totalEmails <= 60) {
                        batchStrategy = [30, totalEmails - 30];
                    } else if (totalEmails <= 100) {
                        const fullBatches = Math.floor(totalEmails / 30);
                        const remainder = totalEmails % 30;
                        batchStrategy = Array(fullBatches).fill(30);
                        if (remainder > 0) {
                            if (remainder < 10 && fullBatches > 0) {
                                batchStrategy[batchStrategy.length - 1] += remainder;
                            } else {
                                batchStrategy.push(remainder);
                            }
                        }
                    } else {
                        const batchSize = 25;
                        const fullBatches = Math.floor(totalEmails / batchSize);
                        const remainder = totalEmails % batchSize;
                        batchStrategy = Array(fullBatches).fill(batchSize);
                        if (remainder > 0) {
                            if (remainder < 10 && fullBatches > 0) {
                                batchStrategy[batchStrategy.length - 1] += remainder;
                            } else {
                                batchStrategy.push(remainder);
                            }
                        }
                    }
                    
                    const strategyText = batchStrategy.map((size, index) => 
                        `第${index + 1}批: ${size}个`
                    ).join(', ');
                    
                    updateLoadingText(`正在优化AI处理策略... 共${totalEmails}个邮箱将分${batchStrategy.length}批处理`);
                    await delay(500);
                    
                    // 按策略批量处理
                    let processedCount = 0;
                    for (let batchIndex = 0; batchIndex < batchStrategy.length; batchIndex++) {
                        const batchSize = batchStrategy[batchIndex];
                        const batch = emailArray.slice(processedCount, processedCount + batchSize);
                        
                        updateLoadingText(`正在处理第 ${batchIndex + 1}/${batchStrategy.length} 批 AI称呼生成 (${processedCount + 1}-${processedCount + batch.length}/${totalEmails})...`);
                        
                        const aiResults = await batchProcessEmailsWithAI(batch);
                        
                        // 将AI结果应用回原始数据
                        batch.forEach(item => {
                            const aiResult = aiResults.get(item.email);
                            if (aiResult) {
                                const positions = emailToResults.get(item.email);
                                positions.forEach(pos => {
                                    const email = currentResults[pos.resultIndex].emails[pos.emailIndex];
                                    if (aiResult.first_name) {
                                        email.first_name = aiResult.first_name;
                                    }
                                    if (aiResult.last_name && !email.last_name) {
                                        email.last_name = aiResult.last_name;
                                    }
                                    email.ai_generated = true;
                                    email.is_guess = aiResult.is_guess;
                                });
                            }
                        });
                        
                        processedCount += batch.length;
                        
                        // 批次间延迟
                        if (batchIndex < batchStrategy.length - 1) {
                            await delay(1000);
                        }
                    }
                    
                    // 更新显示
                    displayResults(currentResults);
                }
                
            } finally {
                showLoading(false);
            }
        }

        // 调用Hunter API
        async function searchDomain(apiKey, domain, companyName = '', limit = 10) {
            // 提取纯域名
            domain = extractDomain(domain);
            
            const url = `https://api.hunter.io/v2/domain-search?domain=${domain}&api_key=${apiKey}&limit=${limit}`;
            AppLogger.debug('调用Hunter API', { domain, limit });
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (!response.ok) {
                    AppLogger.error('Hunter API响应错误', { 
                        domain, 
                        status: response.status,
                        error: data 
                    });
                    
                    if (response.status === 401) {
                        throw new Error('API密钥无效');
                    } else if (response.status === 429) {
                        throw new Error('请求过于频繁，请稍后再试');
                    } else {
                        throw new Error(data.errors?.[0]?.details || '请求失败');
                    }
                }
                
                // 处理结果
                const emails = data.data.emails || [];
                
                AppLogger.info('Hunter API返回结果', { 
                    domain, 
                    emailCount: emails.length,
                    organization: data.data.organization,
                    pattern: data.data.pattern
                });
                
                // 调试：打印第一个邮箱的原始数据
                if (emails.length > 0) {
                    AppLogger.debug('第一个邮箱原始数据', emails[0]);
                }
                
                const processedEmails = emails.map(email => {
                    const processed = {
                        email: email.value,
                        type: email.type || 'unknown',  // personal, generic, or unknown
                        first_name: email.first_name,
                        last_name: email.last_name,
                        position: email.position,
                        department: email.department,
                        confidence: email.confidence,
                        sources: email.sources?.length || 0
                    };
                    
                    // 调试：检查处理后的数据
                    console.log('处理后的邮箱数据:', processed);
                    return processed;
                });
                
                // 异步更新配额信息（不阻塞主流程）
                updateApiQuota(apiKey).catch(console.error);
                
                return {
                    company_name: companyName || data.data.organization || domain,
                    domain: domain,
                    success: true,
                    emails_found: emails.length,
                    emails: processedEmails,
                    pattern: data.data.pattern,
                    organization: data.data.organization
                };
            } catch (error) {
                throw error;
            }
        }

        // 提取域名
        function extractDomain(url) {
            // 移除协议
            url = url.replace(/^https?:\/\//, '');
            // 移除www
            url = url.replace(/^www\./, '');
            // 移除路径
            url = url.split('/')[0];
            // 移除端口
            url = url.split(':')[0];
            return url;
        }

        // 读取上传的文件（支持CSV和TXT/JSON格式）
        async function readUploadedFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const fileName = file.name.toLowerCase();
                    
                    try {
                        if (fileName.endsWith('.csv')) {
                            // 处理CSV格式
                            const lines = text.split('\n');
                            const results = [];
                            
                            for (let i = 1; i < lines.length; i++) { // 跳过标题行
                                const line = lines[i].trim();
                                if (!line) continue;
                                
                                const parts = line.split(',').map(p => p.trim());
                                if (parts.length >= 2) {
                                    results.push({
                                        company_name: parts[0],
                                        domain: parts[1]
                                    });
                                } else if (parts.length === 1) {
                                    results.push({
                                        company_name: '',
                                        domain: parts[0]
                                    });
                                }
                            }
                            
                            resolve(results);
                        } else if (fileName.endsWith('.txt')) {
                            // 使用新的JSON解析方法
                            const { results, errors } = parseMultiArrayJSON(text);
                            
                            if (errors.length > 0) {
                                console.warn('JSON解析警告:', errors);
                                alert(`成功解析 ${results.length} 个公司\n\n${errors.length > 0 ? '注意：\n' + errors.join('\n') : ''}`);
                            } else {
                                console.log(`成功解析 ${results.length} 个公司`);
                            }
                            
                            resolve(results);
                        } else {
                            reject(new Error('不支持的文件格式'));
                        }
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsText(file, 'UTF-8');
            });
        }

        // JSON解析方法
        function parseMultiArrayJSON(text) {
            const results = [];
            const errors = [];
            
            // 将文本按 ][ 分割成多个数组
            text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            
            // 查找所有的JSON数组
            const arrayPattern = /\[\s*\{[\s\S]*?\}\s*\]/g;
            let match;
            let lastEnd = 0;
            
            while ((match = arrayPattern.exec(text)) !== null) {
                try {
                    // 尝试解析找到的数组
                    const arrayStr = match[0];
                    const parsed = JSON.parse(arrayStr);
                    
                    if (Array.isArray(parsed)) {
                        parsed.forEach(item => {
                            results.push({
                                company_name: item.company_name || '',
                                domain: item.website || item.domain || ''
                            });
                        });
                    }
                } catch (e) {
                    // 如果解析失败，尝试修复常见问题
                    try {
                        let fixedStr = match[0]
                            .replace(/,\s*}/g, '}')  // 移除对象末尾的逗号
                            .replace(/,\s*]/g, ']'); // 移除数组末尾的逗号
                        
                        const parsed = JSON.parse(fixedStr);
                        if (Array.isArray(parsed)) {
                            parsed.forEach(item => {
                                results.push({
                                    company_name: item.company_name || '',
                                    domain: item.website || item.domain || ''
                                });
                            });
                            errors.push(`修复并解析了一个格式错误的数组`);
                        }
                    } catch (e2) {
                        errors.push(`无法解析数组: ${e2.message}`);
                    }
                }
                lastEnd = match.index + match[0].length;
            }
            
            // 检查是否有未完成的数组
            const remaining = text.substring(lastEnd).trim();
            if (remaining && remaining.startsWith('[')) {
                // 尝试修复并解析未完成的数组
                try {
                    let fixedArray = remaining;
                    
                    // 如果没有结束的 ]，添加它
                    if (!fixedArray.includes(']')) {
                        // 找到最后一个 }
                        const lastBrace = fixedArray.lastIndexOf('}');
                        if (lastBrace > -1) {
                            fixedArray = fixedArray.substring(0, lastBrace + 1) + '\n]';
                        }
                    }
                    
                    // 移除尾随逗号
                    fixedArray = fixedArray
                        .replace(/,\s*}/g, '}')
                        .replace(/,\s*]/g, ']');
                    
                    const parsed = JSON.parse(fixedArray);
                    if (Array.isArray(parsed)) {
                        parsed.forEach(item => {
                            results.push({
                                company_name: item.company_name || '',
                                domain: item.website || item.domain || ''
                            });
                        });
                        errors.push('处理了文件末尾的未完成数组');
                    }
                } catch (e) {
                    errors.push(`无法解析文件末尾的内容: ${e.message}`);
                }
            }
            
            return { results, errors };
        }

        // 显示结果（支持分页）
        function displayResults(results, page = 1) {
            const resultsDiv = document.getElementById('results');
            const resultContent = document.getElementById('resultContent');
            
            resultsDiv.style.display = 'block';
            currentPage = page;
            
            // 统计信息（显示全部数据的统计）
            const totalCompanies = results.length;
            const successfulCompanies = results.filter(r => r.success).length;
            const totalEmails = results.reduce((sum, r) => sum + (r.emails_found || 0), 0);
            
            // 计算分页
            const totalPages = Math.ceil(totalCompanies / resultsPerPage);
            const startIndex = (page - 1) * resultsPerPage;
            const endIndex = startIndex + resultsPerPage;
            const pageResults = results.slice(startIndex, endIndex);
            
            let html = `
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-number">${totalCompanies}</div>
                        <div class="stat-label">总公司数</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${successfulCompanies}</div>
                        <div class="stat-label">成功查找</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${totalEmails}</div>
                        <div class="stat-label">找到邮箱</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${successfulCompanies > 0 ? Math.round(successfulCompanies/totalCompanies*100) : 0}%</div>
                        <div class="stat-label">成功率</div>
                    </div>
                </div>
            `;
            
            // 分页控件
            if (totalPages > 1) {
                html += createPaginationControls(page, totalPages, totalCompanies);
            }
            
            // 当前页结果
            html += `<div class="page-results">`;
            pageResults.forEach(result => {
                html += `<div class="result-item">`;
                
                if (result.success) {
                    html += `
                        <div class="company-info">
                            <div>
                                <div class="company-name">${result.company_name}</div>
                                <div class="domain">${result.domain}</div>
                            </div>
                            <div class="email-count">${result.emails_found} 个邮箱</div>
                        </div>
                    `;
                    
                    if (result.emails && result.emails.length > 0) {
                        html += '<div class="email-list">';
                        result.emails.forEach(email => {
                            const confidenceClass = email.confidence >= 80 ? 'confidence-high' : 
                                                  email.confidence >= 50 ? 'confidence-medium' : 'confidence-low';
                            
                            // 邮箱类型显示
                            const typeDisplay = email.type === 'personal' ? '个人' : 
                                              email.type === 'generic' ? '通用' : 
                                              email.type === 'role' ? '角色' : '未知';
                            const typeClass = email.type === 'personal' ? 'type-personal' : 
                                            email.type === 'generic' ? 'type-generic' : 'type-unknown';
                            
                            html += `
                                <div class="email-item">
                                    <div>
                                        <div class="email-address">${email.email}</div>
                                        <div class="email-details">
                                            <span class="email-type ${typeClass}">${typeDisplay}</span>
                                            ${email.first_name || email.last_name ? `• ${email.first_name || ''} ${email.last_name || ''}` : ''}
                                            ${email.ai_generated ? `<span style="color: #667eea; font-size: 0.8em;">(AI${email.is_guess ? '猜测' : '提取'})</span>` : ''}
                                            ${email.position ? `• ${email.position}` : ''}
                                            ${email.department ? `• ${email.department}` : ''}
                                        </div>
                                    </div>
                                    <span class="confidence ${confidenceClass}">可信度: ${email.confidence}%</span>
                                </div>
                            `;
                        });
                        html += '</div>';
                    }
                    
                    if (result.pattern) {
                        html += `<div style="margin-top: 10px; color: #666;">邮箱模式: ${result.pattern}</div>`;
                    }
                } else {
                    html += `
                        <div class="company-info">
                            <div>
                                <div class="company-name">${result.company_name}</div>
                                <div class="domain">${result.domain}</div>
                            </div>
                        </div>
                        <div class="error">错误: ${result.error}</div>
                    `;
                }
                
                html += '</div>';
            });
            html += '</div>';
            
            // 底部分页控件
            if (totalPages > 1) {
                html += createPaginationControls(page, totalPages, totalCompanies);
            }
            
            resultContent.innerHTML = html;
        }

        // 创建分页控件
        function createPaginationControls(currentPage, totalPages, totalItems) {
            const startItem = (currentPage - 1) * resultsPerPage + 1;
            const endItem = Math.min(currentPage * resultsPerPage, totalItems);
            
            let html = `
                <div class="pagination">
                    <button onclick="goToPage(1)" ${currentPage === 1 ? 'disabled' : ''}>首页</button>
                    <button onclick="goToPage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>上一页</button>
                    
                    <div class="pagination-info">
                        第 ${startItem}-${endItem} 项，共 ${totalItems} 项 (第 ${currentPage}/${totalPages} 页)
                    </div>
                    
                    <button onclick="goToPage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>下一页</button>
                    <button onclick="goToPage(${totalPages})" ${currentPage === totalPages ? 'disabled' : ''}>末页</button>
                </div>
            `;
            
            return html;
        }

        // 跳转到指定页面
        function goToPage(page) {
            if (page < 1 || page > Math.ceil(currentResults.length / resultsPerPage)) {
                return;
            }
            displayResults(currentResults, page);
            
            // 滚动到结果区域顶部
            document.getElementById('results').scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start' 
            });
        }

        // 下载Instantly AI格式的CSV
        async function downloadInstantlyCSV() {
            if (currentResults.length === 0) return;
            
            try {
                // 添加BOM以支持Excel正确显示中文（UTF-8编码）
                const BOM = '\uFEFF';
                let csv = BOM + 'Email,First Name,Last Name,Company Name,Phone,Job Title,Country,Email Type,AI Generated\n';
                
                for (const result of currentResults) {
                    if (result.success && result.emails && result.emails.length > 0) {
                        // 直接使用已经处理过的邮箱数据（在searchSingle或searchBatch时已经处理过）
                        for (const email of result.emails) {
                            // 处理First Name：如果是通用邮箱，使用公司名+Team
                            let firstName = email.first_name || '';
                            if ((email.type === 'generic' || email.type === 'role') && !firstName) {
                                // 移除公司名称后缀
                                const cleanCompanyName = cleanupCompanyName(result.company_name);
                                firstName = cleanCompanyName ? `${cleanCompanyName} Team` : '';
                            }
                            
                            // 按照Instantly AI要求的字段顺序，加上自定义字段
                            const row = [
                                email.email || '',                    // Email (必填)
                                firstName,                            // First Name (处理后的)
                                email.last_name || '',                // Last Name
                                result.company_name || '',            // Company Name
                                '',                                   // Phone (留空)
                                email.position || '',                 // Job Title
                                '',                                   // Country (留空)
                                email.type || 'unknown',              // Email Type (自定义字段)
                                email.ai_generated ? 'Yes' : 'No'     // AI Generated (标记是否为AI生成)
                            ];
                            
                            // 转义处理
                            const escapedRow = row.map(field => {
                                const str = String(field);
                                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                                    return `"${str.replace(/"/g, '""')}"`;
                                }
                                return str;  // Instantly可能不需要所有字段都加引号
                            });
                            
                            csv += escapedRow.join(',') + '\n';
                        }
                    }
                    // 注意：Instantly格式中，没有邮箱的公司不包含在CSV中
                }
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                downloadFile(csv, `instantly_contacts_${timestamp}.csv`, 'text/csv;charset=utf-8');
                
                // 提示用户
                const enableGuessing = document.getElementById('enableNameGuessing').checked;
                const openaiKey = localStorage.getItem('openaiApiKey');
                
                let alertMessage = '已下载Instantly AI格式的CSV文件\n\n注意：\n- 只包含有邮箱的联系人\n- Phone和Country字段为空，需要时请手动补充\n- Email Type字段标识邮箱类型（personal/generic）\n- 通用邮箱的First Name自动设为"公司名 Team"';
                
                if (enableGuessing && openaiKey) {
                    alertMessage += '\n- AI Generated字段标识名字是否由AI生成';
                }
                
                alert(alertMessage);
                
            } catch (error) {
                console.error('Error downloading CSV:', error);
                alert('下载失败：' + error.message);
            }
        }

        // 下载没有找到邮箱的公司CSV
        function downloadFailedCompaniesCSV() {
            if (currentResults.length === 0) return;
            
            // 筛选出没有找到邮箱的公司
            const failedCompanies = currentResults.filter(result => 
                !result.success || !result.emails || result.emails.length === 0
            );
            
            if (failedCompanies.length === 0) {
                alert('没有找到未成功获取邮箱的公司');
                return;
            }
            
            const BOM = '\uFEFF';
            let csv = BOM + 'Company Name,Domain,Error Message,Status\n';
            
            failedCompanies.forEach(result => {
                const row = [
                    result.company_name || '',
                    result.domain || '',
                    result.error || (result.success ? '未找到邮箱' : '查找失败'),
                    result.success ? '成功但无邮箱' : '查找失败'
                ];
                
                const escapedRow = row.map(field => {
                    const str = String(field);
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return `"${str.replace(/"/g, '""')}"`;
                    }
                    return `"${str}"`;
                });
                
                csv += escapedRow.join(',') + '\n';
            });
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            downloadFile(csv, `failed_companies_${timestamp}.csv`, 'text/csv;charset=utf-8');
            
            alert(`已下载 ${failedCompanies.length} 个未找到邮箱的公司信息`);
        }


        // 下载文件
        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type: type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 清除结果
        function clearResults() {
            currentResults = [];
            currentPage = 1; // 重置分页
            document.getElementById('results').style.display = 'none';
            document.getElementById('singleDomain').value = '';
            document.getElementById('companyName').value = '';
            document.getElementById('batchInput').value = '';
            document.getElementById('csvFile').value = '';
        }

        // 显示/隐藏加载动画
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // 更新加载文字
        function updateLoadingText(text) {
            const loading = document.getElementById('loading');
            const p = loading.querySelector('p');
            if (p) {
                p.textContent = text;
            }
        }

        // 延迟函数
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // API密钥管理功能
        function toggleApiKeyVisibility() {
            const apiKeyInput = document.getElementById('apiKey');
            const toggleIcon = document.getElementById('toggleIcon');
            
            if (apiKeyInput.type === 'password') {
                apiKeyInput.type = 'text';
                toggleIcon.textContent = '🙈';
            } else {
                apiKeyInput.type = 'password';
                toggleIcon.textContent = '👁️';
            }
        }

        function saveApiKey() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                showApiStatus('请输入API密钥', 'error');
                return;
            }
            
            localStorage.setItem('hunterApiKey', apiKey);
            showApiStatus('API密钥已保存', 'success');
        }

        function clearApiKey() {
            if (confirm('确定要清除保存的API密钥吗？')) {
                localStorage.removeItem('hunterApiKey');
                document.getElementById('apiKey').value = '';
                showApiStatus('API密钥已清除', 'success');
            }
        }

        async function testApiKey() {
            const apiKey = getApiKey();
            if (!apiKey) return;
            
            showApiStatus('测试连接中...', 'testing');
            
            try {
                await updateApiQuota(apiKey);
            } catch (error) {
                showApiStatus('网络错误，请检查网络连接', 'error');
            }
        }
        
        // 更新API配额信息
        async function updateApiQuota(apiKey) {
            try {
                const accountUrl = `https://api.hunter.io/v2/account?api_key=${apiKey}`;
                const accountResponse = await fetch(accountUrl);
                const accountData = await accountResponse.json();
                
                if (accountResponse.ok) {
                    const remaining = accountData.data.requests.searches.available;
                    const used = accountData.data.requests.searches.used;
                    const total = remaining + used;
                    
                    showApiStatus(`连接成功！剩余查询次数: ${remaining} (已使用: ${used}/${total})`, 'success');
                    
                    // 保存到全局变量
                    window.hunterApiQuota = { remaining, used, total };
                    
                    // 更新页面标题显示配额
                    updateQuotaDisplay(remaining, used, total);
                    
                    AppLogger.info('API配额更新', { remaining, used, total });
                    
                    return { remaining, used, total };
                } else {
                    showApiStatus('连接成功！', 'success');
                    return null;
                }
            } catch (error) {
                console.error('更新配额失败:', error);
                return null;
            }
        }
        
        // 更新页面上的配额显示
        function updateQuotaDisplay(remaining, used, total) {
            // 在Hunter API密钥区域添加配额显示
            let quotaDisplay = document.getElementById('quotaDisplay');
            if (!quotaDisplay) {
                quotaDisplay = document.createElement('div');
                quotaDisplay.id = 'quotaDisplay';
                quotaDisplay.style.cssText = 'margin-top: 10px; padding: 8px; background: #e6f2ff; border-radius: 5px; font-size: 14px;';
                
                const apiKeySection = document.querySelector('.api-card:first-child .form-group');
                apiKeySection.appendChild(quotaDisplay);
            }
            
            const percentage = ((total - remaining) / total * 100).toFixed(1);
            const now = new Date().toLocaleTimeString();
            quotaDisplay.innerHTML = `
                <strong>📊 API使用情况</strong> <small style="color: #666;">(${now}更新)</small><br>
                剩余: <span style="color: #22543d; font-weight: bold;">${remaining}</span> | 
                已使用: <span style="color: #742a2a;">${used}</span> | 
                总计: ${total} | 
                使用率: <span style="color: ${percentage > 80 ? '#742a2a' : '#22543d'};">${percentage}%</span>
            `;
            
            // 如果使用率过高，显示警告
            if (percentage > 90) {
                quotaDisplay.style.background = '#fed7d7';
                quotaDisplay.style.border = '1px solid #e53e3e';
            } else if (percentage > 80) {
                quotaDisplay.style.background = '#fef3c7';
                quotaDisplay.style.border = '1px solid #f59e0b';
            } else {
                quotaDisplay.style.background = '#e6f2ff';
                quotaDisplay.style.border = 'none';
            }
        }

        function showApiStatus(message, type) {
            const statusElement = document.getElementById('apiStatus');
            statusElement.textContent = message;
            statusElement.className = `api-status ${type}`;
            
            // 保持消息显示，不自动清除
        }

        // 清理公司名称，移除常见后缀
        function cleanupCompanyName(companyName) {
            if (!companyName) return '';
            
            // 常见的公司后缀
            const suffixes = [
                // 英文后缀
                ', LLC', ' LLC', ', INC', ' INC', ', Inc.', ' Inc.', ', Inc', ' Inc',
                ', CORP', ' CORP', ', Corp.', ' Corp.', ', Corp', ' Corp',
                ', LTD', ' LTD', ', Ltd.', ' Ltd.', ', Ltd', ' Ltd',
                ', CO', ' CO', ', Co.', ' Co.', ', Co', ' Co',
                ', COMPANY', ' COMPANY', ', Company', ' Company',
                ', CORPORATION', ' CORPORATION', ', Corporation', ' Corporation',
                ', INCORPORATED', ' INCORPORATED', ', Incorporated', ' Incorporated',
                ', LIMITED', ' LIMITED', ', Limited', ' Limited',
                ', LP', ' LP', ', L.P.', ' L.P.',
                ', LLP', ' LLP', ', L.L.P.', ' L.L.P.',
                ', PC', ' PC', ', P.C.', ' P.C.',
                ', PA', ' PA', ', P.A.', ' P.A.',
                ', PLLC', ' PLLC', ', P.L.L.C.', ' P.L.L.C.',
                ', SERIES', ' SERIES', ', Series', ' Series',
                // 中文后缀
                '有限公司', '股份有限公司', '有限责任公司', '集团', '公司'
            ];
            
            let cleanName = companyName.trim();
            
            // 移除后缀
            for (const suffix of suffixes) {
                if (cleanName.endsWith(suffix)) {
                    cleanName = cleanName.substring(0, cleanName.length - suffix.length).trim();
                    break; // 只移除一个后缀
                }
            }
            
            // 移除多余的标点符号
            cleanName = cleanName.replace(/[,.]$/, '').trim();
            
            return cleanName;
        }

        // 防抖函数
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Claude API相关函数
        function toggleClaudeKeyVisibility() {
            const claudeKeyInput = document.getElementById('claudeKey');
            const toggleIcon = document.getElementById('toggleClaudeIcon');
            
            if (claudeKeyInput.type === 'password') {
                claudeKeyInput.type = 'text';
                toggleIcon.textContent = '🙈';
            } else {
                claudeKeyInput.type = 'password';
                toggleIcon.textContent = '👁️';
            }
        }

        function saveClaudeKey() {
            const claudeKey = document.getElementById('claudeKey').value.trim();
            if (!claudeKey) {
                showClaudeStatus('请输入Claude API密钥', 'error');
                return;
            }
            
            localStorage.setItem('claudeApiKey', claudeKey);
            showClaudeStatus('Claude API密钥已保存', 'success');
        }

        function clearClaudeKey() {
            if (confirm('确定要清除保存的Claude API密钥吗？')) {
                localStorage.removeItem('claudeApiKey');
                document.getElementById('claudeKey').value = '';
                showClaudeStatus('Claude API密钥已清除', 'success');
            }
        }

        async function testClaudeKey() {
            const claudeKey = document.getElementById('claudeKey').value.trim();
            if (!claudeKey) {
                showClaudeStatus('请输入Claude API密钥', 'error');
                return;
            }
            
            showClaudeStatus('测试连接中...', 'testing');
            
            try {
                AppLogger.info('测试Claude API连接', { proxyUrl: CLAUDE_PROXY_URL });
                const response = await fetch(`${CLAUDE_PROXY_URL}/api/claude/test`, {
                    method: 'POST',
                    headers: {
                        'x-api-key': claudeKey,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        showClaudeStatus('连接成功！API密钥有效', 'success');
                    } else {
                        showClaudeStatus(data.error || '连接失败', 'error');
                    }
                } else if (response.status === 401) {
                    showClaudeStatus('API密钥无效，请检查', 'error');
                } else {
                    const errorData = await response.json();
                    showClaudeStatus(errorData.error || '连接失败', 'error');
                }
            } catch (error) {
                console.error('Claude API test error:', error);
                if (error.message.includes('Failed to fetch')) {
                    showClaudeStatus(`无法连接到代理服务器。请确保代理服务器正在运行于 ${CLAUDE_PROXY_URL}`, 'error');
                } else {
                    showClaudeStatus(`网络错误: ${error.message}`, 'error');
                }
            }
        }

        function showClaudeStatus(message, type) {
            const statusElement = document.getElementById('claudeStatus');
            statusElement.textContent = message;
            statusElement.className = `api-status ${type}`;
            
            // 保持消息显示，不自动清除
        }

        // ChatGPT API相关函数
        function toggleOpenAIKeyVisibility() {
            const openaiKeyInput = document.getElementById('openaiKey');
            const toggleIcon = document.getElementById('toggleOpenAIIcon');
            
            if (openaiKeyInput.type === 'password') {
                openaiKeyInput.type = 'text';
                toggleIcon.textContent = '🙈';
            } else {
                openaiKeyInput.type = 'password';
                toggleIcon.textContent = '👁️';
            }
        }

        function saveOpenAIKey() {
            const openaiKey = document.getElementById('openaiKey').value.trim();
            if (!openaiKey) {
                showOpenAIStatus('请输入OpenAI API密钥', 'error');
                return;
            }
            
            localStorage.setItem('openaiApiKey', openaiKey);
            showOpenAIStatus('OpenAI API密钥已保存', 'success');
        }

        function clearOpenAIKey() {
            if (confirm('确定要清除保存的OpenAI API密钥吗？')) {
                localStorage.removeItem('openaiApiKey');
                document.getElementById('openaiKey').value = '';
                showOpenAIStatus('OpenAI API密钥已清除', 'success');
            }
        }

        async function testOpenAIKey() {
            const openaiKey = document.getElementById('openaiKey').value.trim();
            if (!openaiKey) {
                showOpenAIStatus('请输入OpenAI API密钥', 'error');
                return;
            }
            
            showOpenAIStatus('测试连接中...', 'testing');
            
            try {
                const response = await fetch('https://api.openai.com/v1/models', {
                    headers: {
                        'Authorization': `Bearer ${openaiKey}`
                    }
                });
                
                if (response.ok) {
                    showOpenAIStatus('连接成功！API密钥有效', 'success');
                } else if (response.status === 401) {
                    showOpenAIStatus('API密钥无效，请检查', 'error');
                } else {
                    showOpenAIStatus('连接失败，请检查网络', 'error');
                }
            } catch (error) {
                showOpenAIStatus('网络错误，请检查网络连接', 'error');
            }
        }

        function showOpenAIStatus(message, type) {
            const statusElement = document.getElementById('openaiStatus');
            statusElement.textContent = message;
            statusElement.className = `api-status ${type}`;
            
            // 保持消息显示，不自动清除
        }

        // 批量处理邮箱名字猜测
        async function batchProcessEmailsWithAI(emailBatch) {
            if (emailBatch.length === 0) {
                return new Map();
            }
            
            // 检查使用哪个AI服务
            const useOpenAI = document.getElementById('useOpenAI').checked;
            
            if (useOpenAI) {
                return batchProcessWithOpenAI(emailBatch);
            } else {
                return batchProcessWithClaude(emailBatch);
            }
        }
        
        // 使用OpenAI批量处理
        async function batchProcessWithOpenAI(emailBatch) {
            const openaiKey = localStorage.getItem('openaiApiKey');
            if (!openaiKey) {
                return new Map();
            }

            try {
                // 构建批量处理的prompt
                const emailList = emailBatch.map(item => {
                    const domain = item.email.split('@')[1];
                    const domainName = domain.split('.')[0].toUpperCase();
                    const companyDisplayName = item.companyName || domainName;
                    return `${item.email} (公司: ${companyDisplayName})`;
                }).join('\n');

                const prompt = `你是一个严格的邮箱地址分析器。请分析以下邮箱列表，为每个邮箱生成合适的称呼。

重要规则：
1. 只能从邮箱地址本身提取信息，绝不能凭空猜测或添加不存在的姓氏
2. 如果邮箱包含明显的名字和姓氏（如john.doe、ashley.carnes），才提取完整的名字和姓氏
3. 如果邮箱只有名字（如john@），只使用名字，姓氏留空
4. 如果是单个首字母+姓氏（如acarnes），使用首字母大写（如A. Carnes）
5. 如果邮箱前缀不像人名（如info、support），使用"公司名 Team"

邮箱列表：
${emailList}

请返回JSON数组格式，每个邮箱对应一个对象：
[
  {
    "email": "原始邮箱",
    "first_name": "名字或团队名",
    "last_name": "姓氏（如果有）",
    "is_team": true/false,
    "extraction_type": "extracted/partial/team"
  }
]

重要：直接返回纯JSON数组，不要包含markdown代码块标记。`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${openaiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4-turbo-preview',
                        messages: [
                            {
                                role: 'system',
                                content: '你是一个严格的邮箱地址分析器。你只能从邮箱地址中提取实际存在的信息，绝不能凭空创造或猜测不存在的内容。始终返回有效的JSON数组格式。'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        temperature: 0.2,
                        max_tokens: 1000
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    const content = data.choices[0].message.content.trim();
                    
                    try {
                        // 处理可能的markdown代码块包裹
                        let cleanContent = content;
                        if (content.includes('```')) {
                            cleanContent = content.replace(/```json?\n?/g, '').replace(/```\n?/g, '').trim();
                        }
                        
                        const results = JSON.parse(cleanContent);
                        
                        // 将结果转换为Map便于查找
                        const resultMap = new Map();
                        results.forEach(result => {
                            resultMap.set(result.email, {
                                first_name: result.first_name || '',
                                last_name: result.last_name || '',
                                is_guess: result.extraction_type === 'partial',
                                is_team: result.is_team || false
                            });
                        });
                        
                        return resultMap;
                    } catch (parseError) {
                        console.error('Error parsing batch AI response:', parseError);
                        return new Map();
                    }
                }
            } catch (error) {
                console.error('Error in batch processing:', error);
            }

            return new Map();
        }
        
        // 使用Claude批量处理
        async function batchProcessWithClaude(emailBatch) {
            const claudeKey = localStorage.getItem('claudeApiKey');
            if (!claudeKey) {
                return new Map();
            }

            try {
                // 构建批量处理的prompt
                const emailList = emailBatch.map(item => {
                    const domain = item.email.split('@')[1];
                    const domainName = domain.split('.')[0].toUpperCase();
                    const companyDisplayName = item.companyName || domainName;
                    return `${item.email} (公司: ${companyDisplayName})`;
                }).join('\n');

                const prompt = `你是一个严格的邮箱地址分析器。请分析以下邮箱列表，为每个邮箱生成合适的称呼。

重要规则：
1. 只能从邮箱地址本身提取信息，绝不能凭空猜测或添加不存在的姓氏
2. 如果邮箱包含明显的名字和姓氏（如john.doe、ashley.carnes），才提取完整的名字和姓氏
3. 如果邮箱只有名字（如john@），只使用名字，姓氏留空
4. 如果是单个首字母+姓氏（如acarnes），使用首字母大写（如A. Carnes）
5. 如果邮箱前缀不像人名（如info、support），使用"公司名 Team"

邮箱列表：
${emailList}

请返回JSON数组格式，每个邮箱对应一个对象：
[
  {
    "email": "原始邮箱",
    "first_name": "名字或团队名",
    "last_name": "姓氏（如果有）",
    "is_team": true/false,
    "extraction_type": "extracted/partial/team"
  }
]

重要：直接返回纯JSON数组，不要包含markdown代码块标记。`;

                const response = await fetch(`${CLAUDE_PROXY_URL}/api/claude/messages`, {
                    method: 'POST',
                    headers: {
                        'x-api-key': claudeKey,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-5-haiku-20241022',
                        max_tokens: 2500,
                        temperature: 0.2,
                        system: '你是一个严格的邮箱地址分析器。你只能从邮箱地址中提取实际存在的信息，绝不能凭空创造或猜测不存在的内容。始终返回有效的JSON数组格式。',
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    const content = data.content[0].text.trim();
                    
                    try {
                        // 处理可能的markdown代码块包裹
                        let cleanContent = content;
                        if (content.includes('```')) {
                            cleanContent = content.replace(/```json?\n?/g, '').replace(/```\n?/g, '').trim();
                        }
                        
                        const results = JSON.parse(cleanContent);
                        
                        // 将结果转换为Map便于查找
                        const resultMap = new Map();
                        results.forEach(result => {
                            resultMap.set(result.email, {
                                first_name: result.first_name || '',
                                last_name: result.last_name || '',
                                is_guess: result.extraction_type === 'partial',
                                is_team: result.is_team || false
                            });
                        });
                        
                        return resultMap;
                    } catch (parseError) {
                        console.error('Error parsing Claude response:', parseError);
                        return new Map();
                    }
                } else {
                    console.error('Claude API response not ok:', response.status);
                    const errorText = await response.text();
                    console.error('Error details:', errorText);
                }
            } catch (error) {
                console.error('Error in Claude batch processing:', error);
                if (error.message.includes('Failed to fetch')) {
                    console.error('CORS error: Cannot directly call Claude API from browser');
                }
            }

            return new Map();
        }
        
        // 使用ChatGPT猜测名字
        async function guessNameFromEmail(email, companyName) {
            // 检查缓存
            const cacheKey = `${email}|${companyName || ''}`;
            if (nameGuessCache.has(cacheKey)) {
                return nameGuessCache.get(cacheKey);
            }

            const openaiKey = localStorage.getItem('openaiApiKey');
            if (!openaiKey) {
                return { first_name: '', last_name: '' };
            }

            try {
                // 提取域名作为公司名称
                const domain = email.split('@')[1];
                const domainName = domain.split('.')[0].toUpperCase();
                const companyDisplayName = companyName || domainName;
                
                const prompt = `你是一个数据清洗和邮件写作助理，请根据下方提供的邮箱地址，智能提取或生成邮件称呼。

重要规则：
1. 只能从邮箱地址本身提取信息，绝不能凭空猜测或添加不存在的姓氏
2. 如果邮箱包含明显的名字和姓氏（如john.doe、ashley.carnes、john_smith），才提取完整的名字和姓氏
3. 如果邮箱只有名字（如john@、mary@），只使用名字，姓氏留空
4. 如果是单个首字母+姓氏（如acarnes、jsmith），使用首字母大写（如A. Carnes）
5. 如果邮箱前缀不像人名（如info、support、oquxi、sales等），使用"公司名 Team"

数据：
- 公司名: ${companyDisplayName}
- 邮箱: ${email}

请分析后返回JSON格式：
{
    "greeting": "称呼",
    "first_name": "名字或团队名",
    "last_name": "姓氏（如果有）",
    "is_team": true/false,
    "extraction_type": "extracted/partial/team"
}

例子：
- john@company.com → {"greeting": "Dear John,", "first_name": "John", "last_name": "", "is_team": false, "extraction_type": "partial"}
- john.smith@company.com → {"greeting": "Dear John Smith,", "first_name": "John", "last_name": "Smith", "is_team": false, "extraction_type": "extracted"}
- acarnes@company.com → {"greeting": "Dear A. Carnes,", "first_name": "A.", "last_name": "Carnes", "is_team": false, "extraction_type": "extracted"}
- info@company.com → {"greeting": "Dear ${companyDisplayName} Team,", "first_name": "${companyDisplayName} Team", "last_name": "", "is_team": true, "extraction_type": "team"}

重要：直接返回纯JSON，不要包含markdown代码块标记。`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${openaiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4-turbo-preview',  // 使用GPT-4 Turbo
                        messages: [
                            {
                                role: 'system',
                                content: '你是一个严格的邮箱地址分析器。你只能从邮箱地址中提取实际存在的信息，绝不能凭空创造或猜测不存在的内容。如果邮箱只有名字（如john@），就只返回名字。始终返回有效的JSON格式。'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        temperature: 0.2,  // 降低温度使输出更稳定
                        max_tokens: 150
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    const content = data.choices[0].message.content.trim();
                    
                    try {
                        // 处理可能的markdown代码块包裹
                        let cleanContent = content;
                        if (content.includes('```json')) {
                            cleanContent = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                        } else if (content.includes('```')) {
                            cleanContent = content.replace(/```\n?/g, '').trim();
                        }
                        
                        const result = JSON.parse(cleanContent);
                        
                        // 缓存结果
                        nameGuessCache.set(cacheKey, result);
                        
                        // 适配新的返回格式
                        const adaptedResult = {
                            first_name: result.first_name || '',
                            last_name: result.last_name || '',
                            is_guess: !result.is_team && result.first_name && result.first_name.length <= 2,
                            is_team: result.is_team || false,
                            greeting: result.greeting || ''
                        };
                        
                        return adaptedResult;
                    } catch (parseError) {
                        console.error('Error parsing AI response:', parseError);
                        console.error('Original content:', content);
                        return { first_name: '', last_name: '', is_guess: false };
                    }
                }
            } catch (error) {
                console.error('Error guessing name:', error);
            }

            return { first_name: '', last_name: '', is_guess: false };
        }

        // 处理邮箱列表，添加AI猜测的名字
        async function processEmailsWithAI(emails, companyName) {
            const enableGuessing = document.getElementById('enableNameGuessing').checked;
            if (!enableGuessing) {
                return emails;
            }

            const openaiKey = localStorage.getItem('openaiApiKey');
            if (!openaiKey) {
                return emails;
            }

            // 计算需要处理的邮箱数量（包括personal和generic类型）
            const emailsNeedingProcessing = emails.filter(e => 
                (e.type === 'personal' || e.type === 'generic') && !e.first_name
            );
            if (emailsNeedingProcessing.length === 0) {
                return emails;
            }

            // 处理每个邮箱
            const processedEmails = [];
            let processedCount = 0;
            
            for (const email of emails) {
                let processedEmail = { ...email };
                
                // 处理personal和generic类型且没有first_name的邮箱
                if ((email.type === 'personal' || email.type === 'generic') && !email.first_name) {
                    processedCount++;
                    updateLoadingText(`正在使用AI生成称呼 (${processedCount}/${emailsNeedingProcessing.length})...`);
                    
                    const guessedResult = await guessNameFromEmail(email.email, companyName);
                    if (guessedResult && (guessedResult.first_name || guessedResult.last_name)) {
                        // 如果AI猜测了名字，更新邮箱信息
                        if (guessedResult.first_name) {
                            processedEmail.first_name = guessedResult.first_name;
                        }
                        if (guessedResult.last_name && !email.last_name) {
                            processedEmail.last_name = guessedResult.last_name;
                        }
                        processedEmail.ai_generated = true; // 标记为AI生成
                        processedEmail.is_guess = guessedResult.is_guess; // 标记是否为猜测
                    }
                }
                
                processedEmails.push(processedEmail);
            }

            return processedEmails;
        }

        // 通用的展开/收起功能
        function toggleSection(sectionName) {
            const section = document.getElementById(sectionName + 'Section');
            const arrow = document.getElementById(sectionName + 'Arrow');
            
            if (section.style.display === 'none') {
                section.style.display = 'block';
                arrow.classList.add('expanded');
            } else {
                section.style.display = 'none';
                arrow.classList.remove('expanded');
            }
        }
        
        // 日志面板相关功能
        function toggleLogPanel() {
            const panel = document.getElementById('logPanel');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                refreshLogDisplay();
            } else {
                panel.style.display = 'none';
            }
        }
        
        function refreshLogDisplay() {
            const logContent = document.getElementById('logContent');
            const logs = AppLogger.getLogs();
            
            if (logs.length === 0) {
                logContent.innerHTML = '<p style="color: #666;">暂无日志记录</p>';
                return;
            }
            
            // 倒序显示，最新的在上面
            const html = logs.reverse().map(log => {
                const levelColor = {
                    'ERROR': '#dc3545',
                    'WARN': '#ffc107',
                    'INFO': '#28a745',
                    'DEBUG': '#6c757d'
                }[log.level] || '#333';
                
                return `<div style="margin-bottom: 8px; border-left: 3px solid ${levelColor}; padding-left: 8px;">
                    <span style="color: #666;">${new Date(log.timestamp).toLocaleString()}</span>
                    <span style="color: ${levelColor}; font-weight: bold;">[${log.level}]</span>
                    <span>${log.message}</span>
                    ${Object.keys(log.data).length > 0 ? `<br><span style="color: #666; font-size: 11px;">${JSON.stringify(log.data)}</span>` : ''}
                </div>`;
            }).join('');
            
            logContent.innerHTML = html;
        }
        
        // 显示代理服务器设置说明
        function showProxySetup() {
            alert(`Claude API 代理服务器设置说明：

1. 安装Node.js (如果还没有安装)
2. 进入 claude-proxy-server 目录
3. 运行: npm install
4. 启动服务器: npm start
5. 服务器将在 http://localhost:3001 运行

详细说明请查看 claude-proxy-server/README.md`);
        }
        
        // 展开/收起功能
        function toggleApiInfo(type) {
            const infoDiv = document.getElementById(type + 'ApiInfo');
            const arrow = document.getElementById(type + 'Arrow');
            
            if (infoDiv.style.display === 'none') {
                infoDiv.style.display = 'block';
                arrow.classList.add('expanded');
            } else {
                infoDiv.style.display = 'none';
                arrow.classList.remove('expanded');
            }
        }
        
        // 检查Claude代理服务器状态
        async function checkProxyServerStatus() {
            try {
                const response = await fetch(`${CLAUDE_PROXY_URL}/health`);
                if (response.ok) {
                    console.log('Claude代理服务器运行正常');
                    return true;
                }
            } catch (error) {
                console.log('Claude代理服务器未运行');
                return false;
            }
            return false;
        }
        
        // 显示服务器状态提示
        async function showServerStatusNotification() {
            const usesClaude = document.getElementById('useClaude').checked;
            if (usesClaude) {
                const isRunning = await checkProxyServerStatus();
                if (!isRunning) {
                    const message = `Claude代理服务器未运行！\n\n请运行以下命令启动：\n1. cd claude-proxy-server\n2. npm start\n\n或者双击"启动Hunter工具.command"文件`;
                    alert(message);
                }
            }
        }
        
        // CSV文件预览功能
        async function previewCsvFile() {
            const fileInput = document.getElementById('greetingCsvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                document.getElementById('csvPreview').style.display = 'none';
                return;
            }
            
            try {
                const text = await file.text();
                const lines = text.split('\n').filter(line => line.trim());
                
                if (lines.length === 0) {
                    alert('CSV文件为空');
                    return;
                }
                
                // 解析CSV头部
                const headers = parseCSVLine(lines[0]);
                
                // 尝试找到email列
                const emailColumnIndex = headers.findIndex(header => 
                    header.toLowerCase().includes('email') || 
                    header.toLowerCase() === 'e-mail' ||
                    header.toLowerCase() === 'mail'
                );
                
                if (emailColumnIndex === -1) {
                    alert('未找到email列，请确保CSV文件包含email列');
                    return;
                }
                
                // 显示预览
                const previewDiv = document.getElementById('csvPreview');
                const previewContent = document.getElementById('csvPreviewContent');
                const detectedColumns = document.getElementById('detectedColumns');
                
                previewDiv.style.display = 'block';
                detectedColumns.textContent = headers.join(', ');
                
                // 显示前5行数据
                let previewHtml = '<table style="width: 100%; font-size: 12px;">';
                previewHtml += '<thead><tr>';
                headers.forEach((header, index) => {
                    const highlight = index === emailColumnIndex ? 'style="background: #e6f2ff; font-weight: bold;"' : '';
                    previewHtml += `<th ${highlight}>${escapeHtml(header)}</th>`;
                });
                previewHtml += '</tr></thead><tbody>';
                
                for (let i = 1; i < Math.min(6, lines.length); i++) {
                    const values = parseCSVLine(lines[i]);
                    previewHtml += '<tr>';
                    values.forEach((value, index) => {
                        const highlight = index === emailColumnIndex ? 'style="background: #e6f2ff;"' : '';
                        previewHtml += `<td ${highlight}>${escapeHtml(value || '')}</td>`;
                    });
                    previewHtml += '</tr>';
                }
                
                previewHtml += '</tbody></table>';
                previewHtml += `<div style="margin-top: 10px; color: #666;">共 ${lines.length - 1} 行数据</div>`;
                
                previewContent.innerHTML = previewHtml;
                
                // 保存解析信息供后续使用
                window.csvParseInfo = {
                    headers,
                    emailColumnIndex,
                    totalRows: lines.length - 1
                };
                
            } catch (error) {
                alert('读取CSV文件失败: ' + error.message);
                AppLogger.error('CSV文件读取失败', { error: error.message });
            }
        }
        
        // 解析CSV行（处理逗号和引号）
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        current += '"';
                        i++; // 跳过下一个引号
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            values.push(current.trim());
            return values;
        }
        
        // HTML转义
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // 仅生成称呼功能
        async function generateGreetingsOnly() {
            const fileInput = document.getElementById('greetingCsvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('请先选择CSV文件');
                return;
            }
            
            // 检查AI设置
            const enableGuessing = document.getElementById('enableNameGuessing').checked;
            if (!enableGuessing) {
                alert('请先启用"智能猜测名字"功能');
                return;
            }
            
            const useOpenAI = document.getElementById('useOpenAI').checked;
            const openaiKey = localStorage.getItem('openaiApiKey');
            const claudeKey = localStorage.getItem('claudeApiKey');
            const hasValidKey = useOpenAI ? openaiKey : claudeKey;
            
            if (!hasValidKey) {
                alert(`请先设置${useOpenAI ? 'OpenAI' : 'Claude'} API密钥`);
                return;
            }
            
            try {
                showLoading(true);
                updateLoadingText('正在读取CSV文件...');
                
                const text = await file.text();
                const lines = text.split('\n').filter(line => line.trim());
                
                if (!window.csvParseInfo) {
                    alert('请重新选择文件');
                    return;
                }
                
                const { headers, emailColumnIndex } = window.csvParseInfo;
                const overrideExisting = document.getElementById('overrideGreetings').checked;
                
                // 查找可能的名字列
                const firstNameIndex = headers.findIndex(h => 
                    h.toLowerCase().includes('first') || 
                    h.toLowerCase() === 'firstname' ||
                    h.toLowerCase() === 'fname'
                );
                const lastNameIndex = headers.findIndex(h => 
                    h.toLowerCase().includes('last') || 
                    h.toLowerCase() === 'lastname' ||
                    h.toLowerCase() === 'lname'
                );
                const companyIndex = headers.findIndex(h => 
                    h.toLowerCase().includes('company') || 
                    h.toLowerCase() === 'organization'
                );
                
                // 收集需要处理的邮箱
                const emailsToProcess = [];
                const processedData = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = parseCSVLine(lines[i]);
                    const email = values[emailColumnIndex];
                    
                    if (!email || !email.includes('@')) continue;
                    
                    const hasFirstName = firstNameIndex !== -1 && values[firstNameIndex];
                    const shouldProcess = overrideExisting || !hasFirstName;
                    
                    const rowData = {
                        originalIndex: i,
                        values: [...values],
                        email: email,
                        company: companyIndex !== -1 ? values[companyIndex] : email.split('@')[1]
                    };
                    
                    if (shouldProcess) {
                        emailsToProcess.push({
                            email: email,
                            companyName: rowData.company
                        });
                    }
                    
                    processedData.push(rowData);
                }
                
                AppLogger.info('CSV分析完成', {
                    totalRows: processedData.length,
                    toProcess: emailsToProcess.length
                });
                
                if (emailsToProcess.length === 0) {
                    alert('没有需要处理的邮箱（所有邮箱都已有名字）');
                    showLoading(false);
                    return;
                }
                
                // 智能计算最优批次策略
                const totalEmails = emailsToProcess.length;
                let batchStrategy = [];
                
                if (totalEmails <= 30) {
                    // 30个以内，一次处理完
                    batchStrategy = [totalEmails];
                } else if (totalEmails <= 60) {
                    // 31-60个，分2批，每批30个
                    batchStrategy = [30, totalEmails - 30];
                } else if (totalEmails <= 100) {
                    // 61-100个，前几批30个，最后一批处理剩余
                    const fullBatches = Math.floor(totalEmails / 30);
                    const remainder = totalEmails % 30;
                    batchStrategy = Array(fullBatches).fill(30);
                    if (remainder > 0) {
                        if (remainder < 10 && fullBatches > 0) {
                            // 如果剩余少于10个，合并到上一批
                            batchStrategy[batchStrategy.length - 1] += remainder;
                        } else {
                            batchStrategy.push(remainder);
                        }
                    }
                } else {
                    // 100个以上，每批25个，避免单批过大
                    const batchSize = 25;
                    const fullBatches = Math.floor(totalEmails / batchSize);
                    const remainder = totalEmails % batchSize;
                    batchStrategy = Array(fullBatches).fill(batchSize);
                    if (remainder > 0) {
                        if (remainder < 10 && fullBatches > 0) {
                            batchStrategy[batchStrategy.length - 1] += remainder;
                        } else {
                            batchStrategy.push(remainder);
                        }
                    }
                }
                
                // 显示批次策略
                const strategyText = batchStrategy.map((size, index) => 
                    `第${index + 1}批: ${size}个`
                ).join(', ');
                
                AppLogger.info('AI批次处理策略', {
                    totalEmails,
                    strategy: batchStrategy,
                    strategyText
                });
                
                updateLoadingText(`正在分析处理策略... 共${totalEmails}个邮箱将分${batchStrategy.length}批处理 (${strategyText})`);
                await delay(1000);
                
                // 按照策略批量处理
                const aiResults = new Map();
                let processedCount = 0;
                
                for (let batchIndex = 0; batchIndex < batchStrategy.length; batchIndex++) {
                    const batchSize = batchStrategy[batchIndex];
                    const batch = emailsToProcess.slice(processedCount, processedCount + batchSize);
                    
                    updateLoadingText(`正在处理第 ${batchIndex + 1}/${batchStrategy.length} 批 (${processedCount + 1}-${processedCount + batch.length}/${totalEmails})...`);
                    
                    const batchResults = await batchProcessEmailsWithAI(batch);
                    batchResults.forEach((result, email) => {
                        aiResults.set(email, result);
                    });
                    
                    processedCount += batch.length;
                    
                    // 批次间延迟，避免API限流
                    if (batchIndex < batchStrategy.length - 1) {
                        updateLoadingText(`第 ${batchIndex + 1} 批完成，等待1秒后继续...`);
                        await delay(1000);
                    }
                }
                
                // 应用AI结果到数据
                let updatedCount = 0;
                let firstNameAdded = false;
                
                processedData.forEach(row => {
                    const aiResult = aiResults.get(row.email);
                    if (aiResult) {
                        // 更新或添加first_name列
                        if (firstNameIndex !== -1) {
                            if (overrideExisting || !row.values[firstNameIndex]) {
                                row.values[firstNameIndex] = aiResult.first_name || '';
                                updatedCount++;
                            }
                        } else {
                            // 如果没有first_name列，添加一个
                            if (!firstNameAdded) {
                                headers.push('first_name');
                                firstNameAdded = true;
                            }
                            row.values.push(aiResult.first_name || '');
                            updatedCount++;
                        }
                        
                        // 更新或添加last_name列（如果AI返回了）
                        if (aiResult.last_name && lastNameIndex !== -1) {
                            if (!row.values[lastNameIndex]) {
                                row.values[lastNameIndex] = aiResult.last_name;
                            }
                        }
                    } else if (firstNameIndex === -1 && firstNameAdded) {
                        // 如果添加了first_name列，确保所有行都有相应的值
                        row.values.push('');
                    }
                });
                
                // 生成新的CSV
                updateLoadingText('正在生成CSV文件...');
                
                const BOM = '\uFEFF';
                let newCsv = BOM + headers.map(h => `"${h.replace(/"/g, '""')}"`).join(',') + '\n';
                
                processedData.forEach(row => {
                    newCsv += row.values.map(v => {
                        const str = String(v || '');
                        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                            return `"${str.replace(/"/g, '""')}"`;
                        }
                        return `"${str}"`;
                    }).join(',') + '\n';
                });
                
                // 保存生成的CSV到全局变量
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const originalName = file.name.replace('.csv', '');
                const fileName = `${originalName}_with_greetings_${timestamp}.csv`;
                
                window.generatedGreetingCsv = {
                    content: newCsv,
                    fileName: fileName,
                    processedCount: emailsToProcess.length,
                    updatedCount: updatedCount
                };
                
                // 显示结果和下载按钮
                showGreetingResults();
                
                AppLogger.info('CSV称呼生成完成', {
                    processed: emailsToProcess.length,
                    updated: updatedCount
                });
                
            } catch (error) {
                AppLogger.error('生成称呼失败', { error: error.message });
                alert('生成称呼失败: ' + error.message);
            } finally {
                showLoading(false);
            }
        }
        
        // 显示称呼生成结果
        function showGreetingResults() {
            const results = window.generatedGreetingCsv;
            if (!results) return;
            
            const resultDiv = document.getElementById('greetingResults');
            const resultText = document.getElementById('greetingResultText');
            
            resultText.innerHTML = `
                <strong>处理完成！</strong><br>
                • 处理了 ${results.processedCount} 个邮箱<br>
                • 更新了 ${results.updatedCount} 个名字<br>
                • 文件名：${results.fileName}
            `;
            
            resultDiv.style.display = 'block';
            
            // 滚动到结果区域
            resultDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // 下载生成的称呼文件
        function downloadGeneratedGreetings() {
            const results = window.generatedGreetingCsv;
            if (!results) {
                alert('没有可下载的文件');
                return;
            }
            
            downloadFile(results.content, results.fileName, 'text/csv;charset=utf-8');
            
            AppLogger.info('下载称呼文件', { fileName: results.fileName });
        }
        
        // 清除称呼生成结果
        function clearGreetingResults() {
            document.getElementById('greetingResults').style.display = 'none';
            document.getElementById('greetingCsvFile').value = '';
            document.getElementById('csvPreview').style.display = 'none';
            window.generatedGreetingCsv = null;
            window.csvParseInfo = null;
        }
        
        // JSON文件处理相关功能
        async function previewJsonFile() {
            const fileInput = document.getElementById('jsonFile');
            const file = fileInput.files[0];
            
            if (!file) {
                document.getElementById('jsonPreview').style.display = 'none';
                return;
            }
            
            try {
                const text = await file.text();
                
                // 显示预览
                const previewDiv = document.getElementById('jsonPreview');
                const previewContent = document.getElementById('jsonPreviewContent');
                const jsonStats = document.getElementById('jsonStats');
                
                previewDiv.style.display = 'block';
                
                // 显示前1000个字符
                const previewText = text.length > 1000 ? text.substring(0, 1000) + '...\n(文件过大，仅显示前1000个字符)' : text;
                previewContent.textContent = previewText;
                
                // 尝试解析并统计
                const { results, errors } = parseMultiArrayJSON(text);
                const stats = `找到 ${results.length} 条记录${errors.length > 0 ? `, ${errors.length} 个警告` : ''}`;
                jsonStats.textContent = stats;
                
                // 保存解析结果供后续使用
                window.jsonParsePreview = { text, results, errors };
                
            } catch (error) {
                alert('读取文件失败: ' + error.message);
                AppLogger.error('JSON文件读取失败', { error: error.message });
            }
        }
        
        // 处理JSON文件
        async function processJsonFile() {
            const fileInput = document.getElementById('jsonFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('请先选择文件');
                return;
            }
            
            try {
                showLoading(true);
                updateLoadingText('正在处理JSON文件...');
                
                // 使用预览时的解析结果或重新解析
                let parseResult;
                if (window.jsonParsePreview && window.jsonParsePreview.text) {
                    parseResult = window.jsonParsePreview;
                } else {
                    const text = await file.text();
                    parseResult = { ...parseMultiArrayJSON(text), text };
                }
                
                let { results, errors } = parseResult;
                const originalCount = results.length;
                
                // 去重处理
                const removeDuplicates = document.getElementById('removeDuplicates').checked;
                if (removeDuplicates && results.length > 0) {
                    updateLoadingText('正在去除重复数据...');
                    const domainMap = new Map();
                    
                    results.forEach(item => {
                        const domain = extractDomain(item.domain);
                        if (domain && !domainMap.has(domain)) {
                            domainMap.set(domain, {
                                company_name: item.company_name || domain,
                                domain: domain
                            });
                        }
                    });
                    
                    results = Array.from(domainMap.values());
                }
                
                const duplicatesRemoved = originalCount - results.length;
                
                // 保存处理结果
                window.processedJsonData = {
                    results,
                    originalCount,
                    duplicatesRemoved,
                    errors,
                    fileName: file.name
                };
                
                // 显示结果
                showJsonResults();
                
                AppLogger.info('JSON文件处理完成', {
                    originalCount,
                    finalCount: results.length,
                    duplicatesRemoved,
                    errors: errors.length
                });
                
            } catch (error) {
                AppLogger.error('处理JSON文件失败', { error: error.message });
                alert('处理文件失败: ' + error.message);
            } finally {
                showLoading(false);
            }
        }
        
        // 显示JSON处理结果
        function showJsonResults() {
            const data = window.processedJsonData;
            if (!data) return;
            
            const resultDiv = document.getElementById('jsonResults');
            const resultText = document.getElementById('jsonResultText');
            
            resultText.innerHTML = `
                <strong>处理统计：</strong><br>
                • 原始记录数：${data.originalCount}<br>
                • 去除重复：${data.duplicatesRemoved}<br>
                • 最终记录数：${data.results.length}<br>
                ${data.errors.length > 0 ? `• 处理警告：${data.errors.length} 个<br>` : ''}
                • 文件名：${data.fileName}
            `;
            
            resultDiv.style.display = 'block';
            resultDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // 下载处理后的JSON
        function downloadProcessedJson() {
            const data = window.processedJsonData;
            if (!data || !data.results) {
                alert('没有可下载的数据');
                return;
            }
            
            const jsonContent = JSON.stringify(data.results, null, 2);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const fileName = `processed_companies_${timestamp}.json`;
            
            downloadFile(jsonContent, fileName, 'application/json');
            AppLogger.info('下载JSON文件', { fileName, count: data.results.length });
        }
        
        // 下载处理后的CSV
        function downloadProcessedCsv() {
            const data = window.processedJsonData;
            if (!data || !data.results) {
                alert('没有可下载的数据');
                return;
            }
            
            const BOM = '\uFEFF';
            let csv = BOM + 'company_name,domain\n';
            
            data.results.forEach(item => {
                const companyName = (item.company_name || '').replace(/"/g, '""');
                const domain = (item.domain || '').replace(/"/g, '""');
                csv += `"${companyName}","${domain}"\n`;
            });
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const fileName = `processed_companies_${timestamp}.csv`;
            
            downloadFile(csv, fileName, 'text/csv;charset=utf-8');
            AppLogger.info('下载CSV文件', { fileName, count: data.results.length });
        }
        
        // 复制到剪贴板
        async function copyToClipboard() {
            const data = window.processedJsonData;
            if (!data || !data.results) {
                alert('没有可复制的数据');
                return;
            }
            
            try {
                const jsonContent = JSON.stringify(data.results, null, 2);
                await navigator.clipboard.writeText(jsonContent);
                alert(`已复制 ${data.results.length} 条记录到剪贴板`);
                AppLogger.info('复制到剪贴板', { count: data.results.length });
            } catch (error) {
                alert('复制失败，请手动选择下载');
                AppLogger.error('复制到剪贴板失败', { error: error.message });
            }
        }
        
        // 清除JSON处理结果
        function clearJsonResults() {
            document.getElementById('jsonResults').style.display = 'none';
            document.getElementById('jsonFile').value = '';
            document.getElementById('jsonPreview').style.display = 'none';
            window.processedJsonData = null;
            window.jsonParsePreview = null;
        }
        
        // 滚动到顶部
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // 滚动到底部
        function scrollToBottom() {
            window.scrollTo({
                top: document.documentElement.scrollHeight,
                behavior: 'smooth'
            });
        }
        
        // 监听滚动事件，智能显示/隐藏按钮
        let scrollTimer;
        window.addEventListener('scroll', function() {
            const scrollButtons = document.querySelector('.scroll-buttons');
            
            // 显示按钮
            if (scrollButtons) {
                scrollButtons.classList.remove('hidden');
                
                // 清除之前的定时器
                clearTimeout(scrollTimer);
                
                // 设置新的定时器，3秒后隐藏
                scrollTimer = setTimeout(() => {
                    scrollButtons.classList.add('hidden');
                }, 3000);
            }
        });
        
        // 全局错误捕获
        window.addEventListener('error', function(event) {
            AppLogger.error('全局错误', {
                message: event.message,
                filename: event.filename,
                line: event.lineno,
                column: event.colno,
                error: event.error?.stack
            });
        });
        
        window.addEventListener('unhandledrejection', function(event) {
            AppLogger.error('未处理的Promise错误', {
                reason: event.reason,
                promise: event.promise
            });
        });
        
        // 页面加载时的初始化
        document.addEventListener('DOMContentLoaded', async function() {
            // 加载保存的日志
            AppLogger.loadLogs();
            AppLogger.info('Hunter邮箱查找工具启动', { 
                version: '1.0',
                userAgent: navigator.userAgent 
            });
            // 保存API密钥到本地存储（输入时自动保存）
            const apiKeyInput = document.getElementById('apiKey');
            if (apiKeyInput) {
                apiKeyInput.addEventListener('input', debounce(function() {
                    const apiKey = this.value ? this.value.trim() : '';
                    if (apiKey) {
                        localStorage.setItem('hunterApiKey', apiKey);
                    }
                }, 1000));
            }

            // 恢复保存的API密钥
            const savedApiKey = localStorage.getItem('hunterApiKey');
            if (savedApiKey) {
                document.getElementById('apiKey').value = savedApiKey;
                showApiStatus('已加载保存的API密钥', 'success');
                // 自动测试连接并更新配额
                setTimeout(async () => {
                    await testApiKey();
                }, 500);
            }

            // 恢复保存的OpenAI API密钥
            const savedOpenAIKey = localStorage.getItem('openaiApiKey');
            if (savedOpenAIKey) {
                document.getElementById('openaiKey').value = savedOpenAIKey;
                showOpenAIStatus('已加载保存的OpenAI API密钥', 'success');
            }
            
            // 恢复保存的Claude API密钥
            const savedClaudeKey = localStorage.getItem('claudeApiKey');
            if (savedClaudeKey) {
                document.getElementById('claudeKey').value = savedClaudeKey;
                showClaudeStatus('已加载保存的Claude API密钥', 'success');
            }
            
            // 恢复AI提供商选择（默认使用OpenAI，因为Claude有CORS限制）
            const savedAIProvider = localStorage.getItem('aiProvider');
            if (savedAIProvider === 'claude') {
                document.getElementById('useClaude').checked = true;
                // 延迟检查服务器状态，让页面先加载完成
                setTimeout(() => {
                    showServerStatusNotification();
                }, 1000);
            } else {
                // 默认使用OpenAI
                document.getElementById('useOpenAI').checked = true;
                if (!savedAIProvider) {
                    localStorage.setItem('aiProvider', 'openai');
                }
            }

            // 恢复智能猜测名字的设置（默认为true）
            const savedEnableNameGuessing = localStorage.getItem('enableNameGuessing');
            const enableNameGuessing = savedEnableNameGuessing === null ? true : savedEnableNameGuessing === 'true';
            document.getElementById('enableNameGuessing').checked = enableNameGuessing;

            // 保存智能猜测名字的设置
            document.getElementById('enableNameGuessing').addEventListener('change', function() {
                localStorage.setItem('enableNameGuessing', this.checked);
            });

            // OpenAI密钥输入时自动保存
            const openaiKeyInput = document.getElementById('openaiKey');
            if (openaiKeyInput) {
                openaiKeyInput.addEventListener('input', debounce(function() {
                    const openaiKey = this.value ? this.value.trim() : '';
                    if (openaiKey) {
                        localStorage.setItem('openaiApiKey', openaiKey);
                    }
                }, 1000));
            }
            
            // Claude密钥输入时自动保存
            const claudeKeyInput = document.getElementById('claudeKey');
            if (claudeKeyInput) {
                claudeKeyInput.addEventListener('input', debounce(function() {
                    const claudeKey = this.value ? this.value.trim() : '';
                    if (claudeKey) {
                        localStorage.setItem('claudeApiKey', claudeKey);
                    }
                }, 1000));
            }
            
            // 保存AI提供商选择
            document.getElementById('useOpenAI').addEventListener('change', function() {
                if (this.checked) {
                    localStorage.setItem('aiProvider', 'openai');
                }
            });
            
            document.getElementById('useClaude').addEventListener('change', async function() {
                if (this.checked) {
                    localStorage.setItem('aiProvider', 'claude');
                    // 检查服务器状态
                    await showServerStatusNotification();
                }
            });
            
            // 保存代理URL
            const proxyUrlInput = document.getElementById('proxyUrl');
            if (proxyUrlInput) {
                // 恢复保存的代理URL
                const savedProxyUrl = localStorage.getItem('claudeProxyUrl');
                if (savedProxyUrl) {
                    proxyUrlInput.value = savedProxyUrl;
                }
                
                // 监听变化并保存
                proxyUrlInput.addEventListener('input', debounce(function() {
                    const proxyUrl = this.value.trim();
                    if (proxyUrl) {
                        localStorage.setItem('claudeProxyUrl', proxyUrl);
                        // 更新全局变量
                        CLAUDE_PROXY_URL = proxyUrl;
                    }
                }, 1000));
            }
        });
    </script>
</body>
</html>